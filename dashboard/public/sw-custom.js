/**
 * Custom Service Worker for AQI Predictor Dashboard
 * 
 * This service worker handles:
 * - Offline request queueing
 * - Background sync
 * - Push notifications
 * - Custom caching strategies
 */

// Import workbox libraries if needed
// This will be generated by next-pwa, but we can extend it

// Queue for offline requests
const QUEUE_NAME = 'aqi-offline-queue';
const SYNC_TAG = 'aqi-sync';

// Listen for sync events
self.addEventListener('sync', (event) => {
  if (event.tag === SYNC_TAG) {
    event.waitUntil(syncOfflineRequests());
  }
});

// Handle background sync
async function syncOfflineRequests() {
  try {
    // Get queued requests from IndexedDB
    const queue = await getQueuedRequests();
    
    for (const request of queue) {
      try {
        const response = await fetch(request.url, {
          method: request.method,
          headers: request.headers,
          body: request.body,
        });
        
        if (response.ok) {
          // Remove from queue
          await removeFromQueue(request.id);
          
          // Notify client about successful sync
          await notifyClients({
            type: 'SYNC_SUCCESS',
            requestId: request.id,
          });
        }
      } catch (error) {
        console.error('Sync failed for request:', request.id, error);
        // Keep in queue for next sync attempt
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

// Get queued requests from IndexedDB
async function getQueuedRequests() {
  // This would use IndexedDB to retrieve queued requests
  // For now, return empty array (will be implemented in queue utility)
  return [];
}

// Remove request from queue
async function removeFromQueue(requestId) {
  // This would remove the request from IndexedDB
}

// Notify all clients about sync status
async function notifyClients(message) {
  const clients = await self.clients.matchAll({ type: 'window' });
  clients.forEach(client => {
    client.postMessage(message);
  });
}

// Handle push notifications
self.addEventListener('push', (event) => {
  if (!event.data) return;
  
  const data = event.data.json();
  const options = {
    body: data.body || 'Air quality alert',
    icon: '/icons/icon-192x192.svg',
    badge: '/icons/icon-72x72.svg',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: data.primaryKey || 1,
      url: data.url || '/',
    },
    actions: [
      {
        action: 'view',
        title: 'View Details',
      },
      {
        action: 'close',
        title: 'Close',
      },
    ],
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title || 'AQI Alert', options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  if (event.action === 'view') {
    event.waitUntil(
      clients.openWindow(event.notification.data.url)
    );
  }
});

// Log service worker activation
self.addEventListener('activate', (event) => {
  console.log('AQI Predictor Service Worker activated');
});

// Log service worker installation
self.addEventListener('install', (event) => {
  console.log('AQI Predictor Service Worker installed');
  // Force the waiting service worker to become the active service worker
  self.skipWaiting();
});

// Handle messages from clients
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'QUEUE_REQUEST') {
    // Queue the request for later sync
    event.waitUntil(queueRequest(event.data.request));
  }
});

// Queue a request for background sync
async function queueRequest(request) {
  // This would add the request to IndexedDB
  // Will be implemented in the queue utility
  
  // Register sync if supported
  if ('sync' in self.registration) {
    await self.registration.sync.register(SYNC_TAG);
  }
}

export {};
